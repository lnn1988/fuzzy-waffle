> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 https://blog.csdn.net/wanderlustLee/article/details/81297253

**二叉查找树：**

二叉查找树就是左结点小于根节点，右结点大于根节点的一种排序树，也叫二叉搜索树。也叫 BST，英文 Binary Sort Tree。

二叉查找树比普通树**查找更快**，查找、插入、删除的时间复杂度为 O（logN）。但是二叉查找树有一种极端的情况，就是会变成一种线性链表似的结构。此时时间复杂度就变味了 O（N），为了解决这种情况，出现了二叉平衡树。

**平衡二叉树：**

平衡二叉树全称平衡二叉搜索树，也叫 AVL 树。是一种自平衡的树。

AVL 树也规定了左结点小于根节点，右结点大于根节点。并且还规定了左子树和右子树的高度差不得超过 1。这样保证了它不会成为线性的链表。AVL 树的**查找稳定**，查找、插入、删除的时间复杂度都为 O（logN），但是由于要维持自身的平衡，所以进行插入和删除结点操作的时候，需要对结点进行**频繁的旋转。**

AVL 树每一个节点只能存放一个元素，并且每个节点只有两个子节点。当进行查找时，就**需要多次磁盘 IO**，（数据是存放在磁盘中的，每次查询是将磁盘中的一页数据加入内存，树的每一层节点存放在一页中，不同层数据存放在不同页。）这样如果需要多层查询就需要多次磁盘 IO。为了解决 AVL 树的这个问题，就出现了 B 树。

**B 树：**

B 树也叫平衡树，也叫作 B - 树，英文为 Blance-Tree。是一种多路平衡树。

一个 m 阶的 B 树规定了：

1. 根结点至少有两个子女。

2. 每个中间节点都包含 k-1 个元素和 k 个孩子，其中 m/2 <= k <= m 。

3. 每一个叶子节点都包含 k-1 个元素，其中 m/2 <= k <= m。

4. 所有的叶子结点都位于同一层。

5. 每个节点中的元素从小到大排列，节点当中 k-1 个元素正好是 k 个孩子包含的元素的值域分划。

![](https://img-blog.csdn.net/20180731103603131?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmRlcmx1c3RMZWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

B 树每一层存放了更多的节点，由 AVL 树的 “瘦高” 变成了“矮胖”。可以**相对减少磁盘 IO 的次数**。MongoDB 的索引就是用 B 树实现的。

B 树也是一种**自平衡**的树，在进行插入和删除操作时也需要对结点进行旋转等操作。

不过，B 树的**查找不稳定**，最好的情况就是在根节点查到了，最坏的情况就是在叶子结点查到。另外，B 树在**遍历方面比较麻烦**，由于需要进行中序遍历，所以也会进行一定数量的磁盘 IO。为了解决这些问题，出现了 B + 树。

**B + 树：**

B + 树每个非叶子结点存放的元素只用于索引作用，所有数据保存在叶子结点。

一个 m 阶的 B + 树规定了：

1. 有 k 个子树的中间节点包含有 k 个元素（B 树中是 k-1 个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。

2. 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

3. 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。

![](https://img-blog.csdn.net/2018073110450943?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmRlcmx1c3RMZWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

因为非叶子结点中存放的元素不存放数据，所以每一层可以容纳更多元素，也就是磁盘中的每一页可以存放更多元素。这样在查找时，**磁盘 IO 的次数也会减少**。

另外，**B + 树的查找稳定**，因为所有的数据都在叶子结点。每个叶子结点也通过指针指向构成了一种链表结构，所以**遍历数据也会简单很多。**

B + 树的插入和删除和 B 树类似。

**红黑树：**

红黑树也叫 RB 树，RB-Tree。是一种自平衡的二叉查找树，它的节点的颜色为红色和黑色。它不严格控制左、右子树高度或节点数之差小于等于 1。也是一种解决二叉查找树极端情况的数据结构。

红黑树规定了：

1. 节点是红色或黑色。

2. 根节点是黑色。

3. 每个叶子节点都是黑色的空节点（NIL 节点）。

4 每个红色节点的两个子节点都是黑色。也就是说从每个叶子到根的所有路径上不能有两个连续的红色节点)。

5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

![](https://img-blog.csdn.net/20180731110029234?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmRlcmx1c3RMZWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

红黑树在查找方面和 AVL 树操作几乎相同。但是在插入和删除操作上，AVL 树每次插入删除会进行大量的平衡度计算，红黑树是牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，结合变色，降低了对旋转的要求，从而提高了性能。红黑树能够以 O(log2 n) 的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在**三次旋转**之内解决。

相比于 BST，因为红黑树可以能确保**树的最长路径不大于两倍的最短路径的长度**，所以可以看出它的查找效果是有最低保证的。在最坏的情况下也可以保证 O(logN) 的，这是要好于二叉查找树的。因为二叉查找树最坏情况可以让查找达到 O(N)。

**红黑树的算法时间复杂度和 AVL 相同**，但**统计性能比 AVL 树更高**，所以在插入和删除中所做的后期维护操作肯定会比红黑树要耗时好多，但是他们的查找效率都是 O(logN)，所以红黑树应用还是高于 AVL 树的. 实际上插入 AVL 树和红黑树的速度取决于你所插入的数据. 如果你的数据分布较好, 则比较宜于采用 AVL 树 (例如随机产生系列数), 但是如果你想处理比较杂乱的情况, 则红黑树是比较快的。

红黑树广泛用于 TreeMap、TreeSet，以及 jdk1.8 后的 HashMap。

学习文章：

[B 树](http://blog.jobbole.com/111757/)

[B + 树](https://www.sohu.com/a/156886901_479559)

[红黑树](https://www.sohu.com/a/201923614_466939)